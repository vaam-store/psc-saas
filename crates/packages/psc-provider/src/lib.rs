#![deny(clippy::all)]
#![forbid(unsafe_code)]

//! Shared Provider trait and a MockProvider implementation for testing.
//!
//! This crate defines the unified Provider interface used by services to interact
//! with mobile-money providers (MTN, Orange, Camtel). The mock implementation
//! allows deterministic testing of success, error and latency scenarios.

use async_trait::async_trait;
use std::time::Duration;

use psc_error::Error;

// Assuming these are generated by Tonic/Prost from the .proto files
// You might need to adjust the paths based on your actual build setup
pub mod pb {
    pub mod common {
        pub mod v1 {
            tonic::include_proto!("psc.common.v1");
        }
    }
    pub mod payment {
        pub mod v1 {
            tonic::include_proto!("psc.payment.v1");
        }
    }
    pub mod payout {
        pub mod v1 {
            tonic::include_proto!("psc.payout.v1");
        }
    }
    pub mod journal {
        pub mod v1 {
            tonic::include_proto!("psc.journal.v1");
        }
    }
    pub mod balance {
        pub mod v1 {
            tonic::include_proto!("psc.balance.v1");
        }
    }
}

use pb::balance::v1::{Balance, GetBalanceRequest};
use pb::common::v1::{Id, Money, Pagination, PaginationRequest, Status, Timestamp};
use pb::journal::v1::{JournalEntry, PostJournalRequest};
use pb::payment::v1::{CreatePaymentRequest, Payment, PaymentStatus};
use pb::payout::v1::{CreatePayoutRequest, Payout, PayoutStatus};

/// Context alias for passing request-scoped metadata.
pub type Ctx = ();

/// Provider trait that abstracts provider operations.
#[async_trait]
pub trait Provider: Send + Sync {
    async fn deposit(&self, ctx: &Ctx, req: CreatePaymentRequest) -> Result<Payment, Error>;
    async fn withdraw(&self, ctx: &Ctx, req: CreatePayoutRequest) -> Result<Payout, Error>;
    async fn refund(&self, ctx: &Ctx, req: PostJournalRequest) -> Result<JournalEntry, Error>;
    async fn query(&self, ctx: &Ctx, req: GetBalanceRequest) -> Result<Balance, Error>;
    async fn verify_webhook(
        &self,
        ctx: &Ctx,
        payload: &[u8],
        signature_header: Option<&str>,
    ) -> Result<bool, Error>;
}

#[cfg(feature = "mock")]
mod mock {
    use super::*;
    use std::sync::Arc;
    use std::time::Instant;
    use tokio::sync::Mutex;

    /// Behavior modes for the MockProvider.
    #[derive(Debug, Clone)]
    pub enum MockBehavior {
        AlwaysSucceed,
        AlwaysFail(String),
        FailOnceThenSucceed,
        Delay(Duration, Box<MockBehavior>),
    }

    /// Internal state for behaviors that need to record invocations.
    #[derive(Debug, Default)]
    struct MockState {
        pub fail_once_consumed: bool,
        pub last_invocation: Option<Instant>,
    }

    /// A configurable mock provider for tests and local development.
    #[derive(Clone)]
    pub struct MockProvider {
        behavior: MockBehavior,
        state: Arc<Mutex<MockState>>,
    }

    impl MockProvider {
        pub fn new(behavior: MockBehavior) -> Self {
            Self {
                behavior,
                state: Arc::new(Mutex::new(MockState::default())),
            }
        }
    }
}
